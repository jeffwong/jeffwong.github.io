[
  {
    "path": "posts/2021-04-10-sparse-model-matrix-optimizations-in-c/",
    "title": "Sparse Model Matrix Optimizations in C++",
    "description": "Using Rcpp to decrease memory usage and increase throughput.",
    "author": [
      {
        "name": "Jeffrey C. Wong",
        "url": {}
      }
    ],
    "date": "2021-04-10",
    "categories": [],
    "contents": "\n\nContents\nData and Model Matrices\nMatrix sparse2int\nOverwriting Functions in Matrix PackageRcppSparse2int\n\nBenchmark\n\nIn this post we will add optimizations to the Matrix::sparse.model.matrix function to increase throughput and decrease memory usage. The optimizations can allow users to create sparse model matrices with interactions 5x faster.\nThe sparse.model.matrix function creates a model matrix that is sparse. This is especially important when there are categorical variables in the data, which will be one-hot encoded and are, by definition, sparse. In addition, interactions with categorical variables are also inherently sparse. Since one-hot encoding generates multiple columns in the feature matrix, we want to make sure storage costs are minimized.\n\n\n\nData and Model Matrices\nLet’s start with a data.frame that has 3 categorical variables, each has 10 unique values.\n\n\nn = 1e5\ndata = data.frame(\n  x1 = sample(LETTERS[1:10], n, replace = TRUE),\n  x2 = sample(LETTERS[1:10], n, replace = TRUE),\n  x3 = sample(LETTERS[1:10], n, replace = TRUE)\n)\ndata %>% head()\n\n\n  x1 x2 x3\n1  H  D  B\n2  C  H  H\n3  J  G  B\n4  F  I  E\n5  D  E  F\n6  A  F  D\n\nA model matrix with all interactions has 1000 columns! However, approximately 8 of those columns are nonzero. The storage cost for such a matrix should be small. Yet, from the RStudio profiler, the memory cost for calling sparse.model.matrix is roughly 700 MB. That is quite large. The bulk of the allocations come from the function Matrix:::sparse2int. Below, we will make a copy of the function and add some optimizations.\n\n\nX1 = sparse.model.matrix(~ x1*x2*x3, data)\ndim(X1)\n\n\n[1] 100000   1000\n\nMatrix sparse2int\nThe role of the Matrix:::sparse2int function is to compute interactions. It receives two blocks of features, \\(X\\) and \\(Y\\). These features are transpose of the original features in the dataframe, so columns in \\(X\\) and \\(Y\\) represent observations and rows represent features. Say \\(x_1\\) is a feature from the \\(X\\) block, and \\(y_1\\) is feature from the \\(Y\\) block. The interaction is simply the product \\(x_1 \\cdot y_1\\). So, for every observation, we want to compute all pairwise products of the features in \\(X\\) and \\(Y\\).\nThis feels like a kronecker product: get feature \\(y_1\\) for every observation and multiply it with everything in \\(X\\); repeat for all features in \\(Y\\). In fact, this operation can be expressed as a kronecker product.\n\n\nr_naive_interaction_kronecker = function(X, Y) {\n  kronecker(rep(1, nrow(Y)), X) * kronecker(Y, rep(1, nrow(X)))\n}\n\n\n\nThe kronecker product kronecker(Y, rep(1, nrow(X))) effectively stretches rows in Y, so that they have the same shape as the X matrix, and can be multipled elementwise. However, it’s not necessary to physically stretch the matrices, we should keep the features compact and recycle instead of stretching them.\nBelow is an example for how to do this using RcppEigen.\nEigen::SparseMatrix<double> sparse_sparse_interaction_kronecker(\n    Eigen::SparseMatrix<double> X,\n    Eigen::SparseMatrix<double> Y\n  ) {\n\n  SparseMatrix<double, RowMajor> output(X.rows() * Y.rows(), X.cols());\n  SparseMatrix<double> Y_transpose = Y.transpose();\n  for (int k=0; k<Y_transpose.outerSize(); ++k) {\n    SparseMatrix<double> X_scaled = X * VectorXd(Y_transpose.col(k)).asDiagonal();\n    X_scaled.prune(0.0);\n    output.middleRows(k * X.rows(), X.rows()) = X_scaled;\n  }\n  return output;\n}\nOverwriting Functions in Matrix Package\nRcppSparse2int\nWe’ll introduce a new function, RcppSparse2int, which implements the interaction kronecker from Rcpp. This is largely a copy of the original Matrix::sparse2int. Next, we will fork a new function: RcppSparse.model.matrix that will invoke RcppSparse2int.\n\n\n#' Faster version of sparse2int.r\n#' \n#' For most cases, we want to compute\n#' kronecker(rep(1, ny), X) * kronecker(Y, rep(1, nx)).\n#' However, we should do this without materializing the kronecker.\n#' This represents a major speedup and reduction in memory\nRcppSparse2int <- function(X, Y, do.names = TRUE, forceSparse = FALSE, verbose = FALSE) {\n  if (do.names) {\n    dnx <- dimnames(X)\n    dny <- dimnames(Y)\n  }\n  dimnames(Y) <- dimnames(X) <- list(NULL, NULL)\n  nx <- nrow(X)\n  ny <- nrow(Y)\n  r <-\n    if ((nX <- is.numeric(X)) | (nY <- is.numeric(Y))) {\n      # At least one was dense\n      if (nX) {\n        # X is dense\n        if (nY) {\n          # Y is also dense\n          dense_dense_interaction_kronecker(X, Y)\n        } else if (nx > 1) {\n          # X has more than 1 row and is dense.\n          # Y is sparse.\n          dense_sparse_interaction_kronecker(X, Y)\n        }\n        # if (nY || nx > 1) { # both numeric, or X >=2 \"columns\"\n        #   F <- if (forceSparse) function(m) .Call(Matrix:::dense_to_Csparse, m) else identity\n        #   # F((if(ny == 1) X else X[rep.int(seq_len(nx),  ny)  , ]) *\n        #   #   (if(nx == 1) Y else Y[rep     (seq_len(ny),each=nx), ]))\n        #   \n        # }\n        else { ## numeric X (1 \"column\"),  sparseMatrix Y\n          r <- Y\n          dp <- Y@p[-1] - Y@p[-(Y@Dim[2] + 1L)]\n          ## stopifnot(all(dp %in% 0:1)) # just for now\n          ## if(nx == 1)\n          ## FIXME: similar trick would be applicable for nx > 2\n          r@x <- X[dp == 1L] * Y@x\n          r\n        }\n      }\n      else { ## sparseMatrix X, dense Y\n        if (ny == 1) {\n          ## FIXME: similar trick would be applicable for ny > 2\n          r <- X\n          dp <- X@p[-1] - X@p[-(X@Dim[2] + 1L)]\n          ## stopifnot(all(dp %in% 0:1)) # just for now - drop! - FIXME\n          r@x <- Y[dp == 1L] * X@x\n          r\n        }\n        else { ## ny > 1 -- *larger* matrix\n          # X is sparse, Y is dense\n          sparse_dense_interaction_kronecker(X, Y)\n        }\n      }\n    }\n  else { ## X & Y are both sparseMatrix\n    sparse_sparse_interaction_kronecker(X, Y)\n  }\n  if (verbose) {\n    cat(sprintf(\n      \" sp..2int(%s[%d],%s[%d]) \",\n      if (nX) \"<N>\" else \"<sparse>\", nx,\n      if (nY) \"<N>\" else \"<sparse>\", ny\n    ))\n  }\n  \n  if (do.names) {\n    ## FIXME: This names business needs a good solution..\n    ##        but maybe \"up in the caller\"\n    if (!is.null(dim(r)) &&\n        !is.null(nX <- dnx[[1]]) &&\n        !is.null(nY <- dny[[1]])) {\n      rownames(r) <- outer(nX, nY, paste, sep = \":\")\n    }\n  }\n  r\n}\n\n\n\n\n\n#' Faster version of sparseInt.r\n#' \n#' This version invokes RcppSparse2int instead of sparse2int,\n#' which in tern invokes Rcpp code to do fast matrix operations.\nRcppSparseInt.r <- function(rList, do.names = TRUE, forceSparse = FALSE, verbose = FALSE) {\n  nl <- length(rList)\n  if (forceSparse) {\n    F <- function(m) if (is.matrix(m)) .Call(Matrix:::dense_to_Csparse, m) else m\n  }\n  if (verbose) {\n    cat(\"RcppSparseInt.r(<list>[1:\", nl, \"], f.Sp=\", forceSparse, \"): is.mat()= (\",\n        paste(symnum(vapply(rList, is.matrix, NA)), collapse = \"\"),\n        \")\\n\",\n        sep = \"\"\n    )\n  }\n  if (nl == 1) {\n    if (forceSparse) F(rList[[1]]) else rList[[1]]\n  } else {\n    ## 'recursion' free:\n    r <- rList[[1]]\n    for (j in 2:nl)\n      r <- RcppSparse2int(r, rList[[j]],\n                          do.names = do.names, verbose = verbose\n      )\n    if (forceSparse) F(r) else r\n  }\n}\n\n#' A faster version of model.spmatrix\n#' \n#' This version calls RcppSparseInt.r instead of sparseint.r.\n#' It also uses RcppSparseMatrixRbindList to bind multiple matrices vertically.\nRcppModel.spmatrix <- function(trms, mf, transpose=FALSE,\n                               drop.unused.levels = FALSE, row.names=TRUE, sep=\"\", verbose=FALSE) {\n  ## Author: Martin Maechler, Date:  7 Jul 2009\n  \n  ## mf is a model frame or a \"simple\" data.frame [after reorder !]\n  stopifnot(is.data.frame(mf))\n  n <- nrow(mf)\n  if(row.names)\n    rnames <- row.names(mf)\n  ## mf:  make into list, dropping all attributes (but the names)\n  ### FIXME: for poly(., 5)  mf has a 5-column matrix as \"one column\" => looses names here\n  fnames <- names(mf <- unclass(mf))\n  attributes(mf) <- list(names = fnames)\n  \n  if(length(factorPattern <- attr(trms, \"factors\"))) {\n    d <- dim(factorPattern)\n    nVar <- d[1]\n    nTrm <- d[2]\n    n.fP <- dimnames(factorPattern)\n    fnames <- n.fP[[1]] # == names of variables {incl. \"F(var)\"} in the model\n    Names  <- n.fP[[2]] # == colnames == names of terms:  \"a\", \"b:c\", ...\n  } else { ## degenerate, e.g.  'Y ~ 1'\n    nVar <- nTrm <- 0L\n    fnames <- Names <- character(0)\n  }\n  ## all the \"variables in the model\" are also in \"mf\", including \"sin(x)\";\n  ## actually, ..../src/main/model.c even assumes\n  stopifnot((m <- length(mf)) >= nVar)\n  if(verbose)\n    cat(sprintf(\"model.spm..(): (n=%d, nVar=%d (m=%d), nTrm=%d)\\n\",\n                n, nVar,m, nTrm))\n  if(m > nVar) mf <- mf[seq_len(nVar)]\n  stopifnot(fnames == names(mf), allow.logical0 = TRUE)\n  noVar <- nVar == 0\n  ##>> this seems wrong; we use  1:nVar for indexing mf[] below ..\n  ##>> if(noVar) nVar <- 1L # (as in ~/R/D/r-devel/R/src/main/model.c)\n  ## Note: \"character\" variables have been changed to factor in the caller;\n  ##     hence: both factor and *logical*  should be dealt as factor :\n  is.f <- if(noVar) logical(0) else vapply(mf, function(.)\n    is.factor(.) | is.logical(.), NA)\n  indF <- which(is.f)\n  if(verbose) { cat(\" --> indF =\\n\"); print(indF) }\n  hasInt <- attr(trms, \"intercept\") == 1\n  ## the degree of interaction:\n  ## intOrder <- attr(trms, \"order\")\n  ##\n  if(!hasInt && length(indF)) {\n    ## change the '1' of the first factor into a '2' :\n    if(any(i1 <- factorPattern[indF, ] == 1))\n      ## replace at the first '1' location:\n      factorPattern[indF,][which.max(i1)] <- 2L\n    else {}\n    ## nothing to do\n  }\n  ## Convert \"factors\" to \"Rowwise- sparseMatrix (\"dummy\"-matrix) -----------\n  ## Result: a list of sparse model matrices for the \"factor\"s :\n  f.matr <- structure(vector(\"list\", length = length(indF)),\n                      names = fnames[indF])\n  i.f <- 0\n  ## ---- For each variable in the model -------------------\n  for(i in seq_len(nVar)) {\n    nam <- fnames[i]\n    f <- mf[[i]]\n    if(is.f[i]) {\n      fp <- factorPattern[i,] ## == factorPattern[nam,]\n      contr <- attr(f, \"contrasts\")\n      f.matr[[(i.f <- i.f + 1)]] <- # a list of 2\n        lapply(fac2Sparse(f, to = \"d\",\n                          drop.unused.levels=drop.unused.levels,\n                          factorPatt12 = 1:2 %in% fp,\n                          contrasts.arg = contr),\n               function(s) {\n                 if(is.null(s)) return(s)\n                 ## else\n                 rownames(s) <- ## for some contr.*(), have lost rownames; hmm..\n                   paste(nam, rownames(s) %||% seq_len(nrow(s)), sep=sep)\n                 s\n               })\n    } else { ## continuous variable --> \"matrix\" - for all of them\n      if(any(iA <- (cl <- class(f)) == \"AsIs\")) # drop \"AsIs\" class\n        class(f) <- if(length(cl) > 1L) cl[!iA]\n      nr <- if(is.matrix(f)) nrow(f <- t(f)) else (dim(f) <- c(1L, length(f)))[1]\n      if(is.null(rownames(f)))\n        rownames(f) <- if(nr == 1) nam else paste(nam, seq_len(nr), sep=sep)\n      mf[[i]] <- f\n    }\n  }\n  if(verbose) {\n    cat(\" ---> f.matr list :\\n\")\n    str(f.matr, max = as.integer(verbose))\n    fNms <- format(dQuote(Names))\n    dim.string <- gsub('5', as.character(floor(1+log10(n))),\n                       \" -- concatenating (r, rj): dim = (%5d,%5d) | (%5d,%5d)\\n\")\n  }\n  \n  ## FIXME: do all this in C --\n  \n  getR <- function(N)      # using 'nm'\n    if(!is.null(r <- f.matr[[N]])) r[[factorPattern[N, nm]]] else mf[[N]]\n  vNms <- \"(Intercept)\"[hasInt]\n  counts <- integer(nTrm)\n  r <-\n    if(hasInt) ## column of 1's - as sparse\n      new(\"dgCMatrix\", i = 0:(n-1L), p = c(0L, n),\n          Dim = c(n, 1L), x = rep.int(1, n))\n  else new(\"dgCMatrix\", Dim = c(n, 0L))\n  if(transpose) r <- t(r)\n  iTrm <- seq_len(nTrm)\n  r.list <- list(r)\n  for(j in iTrm) { ## j-th term\n    nm <- Names[j]\n    if(verbose) cat(sprintf(\"term[%2d] %s .. \", j, fNms[j]))\n    nmSplits <- strsplit(nm, \":\", fixed=TRUE)[[1]]\n    ## NOTA BENE: This can be very slow when many terms are involved\n    ## FIXME ??? why does it use *much* memory in those cases ??\n    # rj <- sparseInt.r(lapply(nmSplits, getR), do.names=TRUE,\n    #                   forceSparse = TRUE, verbose=verbose)# or just (verbose >= 2))\n    rj <- RcppSparseInt.r(lapply(nmSplits, getR),\n                          do.names = TRUE,\n                          forceSparse = TRUE, verbose = verbose\n    )\n    r.list[[j + 1]] <- rj\n    if(verbose) cat(sprintf(dim.string, nrow(r), ncol(r), nrow(rj),ncol(rj)))\n    ## fast version of cbind2() / rbind2(), w/o checks, dimnames, etc\n    # r <- if(transpose) .Call(Csparse_vertcat, r, rj)\n    # else     .Call(Csparse_horzcat, r, t(rj))\n    ## if(verbose) cat(\" [Ok]\\n\")\n    vNms <- c(vNms, dimnames(rj)[[1]])\n    counts[j] <- nrow(rj)\n  }\n  r <- RcppSparseMatrixRbindList(r.list) %>% t()\n  rns <- if(row.names) rnames\n  dimnames(r) <- if (transpose) list(rns, vNms) else list(vNms, rns)\n  attr(r, \"assign\") <- c(if(hasInt) 0L, rep(iTrm, counts))\n  r\n}\n\n#' Sparse Model Matrix\n#'\n#' Rcpp replacement for sparse.model.matrix.\n#' This function replaces the call to model.spmatrix with RcppModel.spmatrix\nRcppSparse.model.matrix <-\n  function(object, data = environment(object), contrasts.arg = NULL,\n           xlev = NULL, transpose = TRUE,\n           drop.unused.levels = FALSE, row.names = TRUE\n           , sep = \"\"\n           , verbose = FALSE, ...)\n  {\n    t <- if(missing(data)) terms(object) else terms(object, data=data)\n    if (is.null(attr(data, \"terms\")))\n      data <- model.frame(object, data, xlev=xlev)\n    else {\n      reorder <- match(sapply(attr(t,\"variables\"),deparse,\n                              width.cutoff=500)[-1L],\n                       names(data))\n      if (anyNA(reorder))\n        stop(\"model frame and formula mismatch in model.matrix()\")\n      if(!isSeq(reorder, ncol(data), Ostart=FALSE))\n        data <- data[,reorder, drop=FALSE]\n    }\n    int <- attr(t, \"response\")\n    if(length(data)) {      # otherwise no rhs terms, so skip all this\n      contr.funs <- as.character(getOption(\"contrasts\"))\n      namD <- names(data)\n      ## turn any character columns into factors\n      for(i in namD)\n        if(is.character(data[[i]]))\n          data[[i]] <- factor(data[[i]])\n      isF <- vapply(data, function(x) is.factor(x) || is.logical(x), NA)\n      isF[int] <- FALSE\n      isOF <- vapply(data, is.ordered, NA)\n      for(nn in namD[isF])            # drop response\n        if(is.null(attr(data[[nn]], \"contrasts\")))\n          contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]\n      ## it might be safer to have numerical contrasts:\n      ##    get(contr.funs[1 + isOF[nn]])(nlevels(data[[nn]]))\n      if (!is.null(contrasts.arg) && is.list(contrasts.arg)) {\n        if (is.null(namC <- names(contrasts.arg)))\n          stop(\"invalid 'contrasts.arg' argument\")\n        for (nn in namC) {\n          if (is.na(ni <- match(nn, namD)))\n            warning(gettextf(\"variable '%s' is absent, its contrast will be ignored\", nn),\n                    domain = NA)\n          else {\n            ca <- contrasts.arg[[nn]]\n            ## FIXME: work for *sparse* ca\n            if(is.matrix(ca)) contrasts(data[[ni]], ncol(ca)) <- ca\n            else contrasts(data[[ni]]) <- contrasts.arg[[nn]]\n          }\n        }\n      }\n    } else {               # internal model.matrix needs some variable\n      isF <-  FALSE\n      data <- cbind(data, x = 0)\n    }\n    ## <Sparse> src/library/stats/R/models.R has\n    ##    ans <- .Internal(model.matrix(t, data))\n    if(verbose) {\n      cat(\"RcppModel.spmatrix(t, data, ..)  with t =\\n\"); str(t,give.attr=FALSE) }\n    ans <- RcppModel.spmatrix(t, data, transpose=transpose,\n                          ##     ==============\n                          drop.unused.levels=drop.unused.levels,\n                          row.names=row.names, sep=sep, verbose=verbose)\n    ## <\/Sparse>\n    attr(ans, \"contrasts\") <-\n      lapply(data[isF], function(x) attr(x, \"contrasts\"))\n    ans\n  } ## {sparse.model.matrix}\n\n\n\nBenchmark\nBelow we benchmark the results for accuracy, and for performance. The new Rcpp interaction kronecker produces the correct answer, and needs only 20% of the time.\n\n\nX1 = sparse.model.matrix(~ x1*x2*x3, data)\nX2 = RcppSparse.model.matrix(~ x1*x2*x3, data)\nidentical(X1, X2)\n\n\n[1] TRUE\n\n\n\nsystem.time(sparse.model.matrix(~ x1*x2*x3, data, row.names = FALSE))\n\n\n   user  system elapsed \n  2.034   0.384   2.423 \n\nsystem.time(RcppSparse.model.matrix(~ x1*x2*x3, data, row.names = FALSE))\n\n\n   user  system elapsed \n  0.451   0.040   0.492 \n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-11T14:46:30-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-09-r-is-a-great-research-environment/",
    "title": "R is a great Research Environment",
    "description": "A thoughtful exposition on how R makes data scientists more productive.",
    "author": [
      {
        "name": "Jeffrey C. Wong",
        "url": {}
      }
    ],
    "date": "2021-04-09",
    "categories": [],
    "contents": "\n\n\n\nR is a data science language, and carries a unique spirit in providing data scientists tools to increase their productivity, and interactively analyze data. Other than being an open source standard, it also receives robust development from RStudio, which has been contributing several data science projects for the R community, such as tidyverse, ggplot, and tidymodels, and sets a high bar for data science software development. The R community has made admirable improvements to data science by improving functionality, performance, design, and both user and developer experience.\nHere are some of the highlights.\nAPI design in the community focuses on individual primitives that are lightweight and easy to map to a single thought, yet can be composed into more complex analyses.\nHigh performance computing through C++.\nRStudio maximizes developer flow by having data import, data modeling, data visualization, the code editor, package development tools, and git all in one IDE.\nThe makers within the R community have a great experience developing packages, including testing, writing and posting online documentation, creating interactive apps, and teaching. That creates a healthy environment for downstream users to always be aligned to best practices.\nFocus on Grammars for Data Analysis\nR has a deep focus on grammars for data analysis that feature very rich and thoughtful API design patterns. The grammars allow data scientists to compose arbitrary analyses in an intuitive way with a few, very robust primitives. This allows data scientists full creative freedom to do the analysis they want, without being blocked by functions that do not stack together. The developer experience becomes aligned and elegant, from the way that a data scientist thinks about an analysis, including inspecting data and intermediate outputs, to the way they communicate it for reproducible research, to the way the analysis is programmed. The grammars span across all critical components of data science: in data wrangling (dplyr & tidyr), data modeling (tidymodels), and data visualization (ggplot2).\nggplot2 - a Grammar for Graphics\n\n\n\nThe most elegant example of a grammar is ggplot2. ggplot composes plots through very simple primitives like geom_bar, geom_point, facet_grid, and coord_flip. Nearly all aspects of the plot are customizeable through ggplot primitives, and they are each scoped in a way that is intuitive to the user. By reading ggplot commands, you immediately have an understanding of what the user is plotting; a geom_bar means the viz will contain a barchart, and coord_flip means the plot will be rotated. Similarly, when you need to write ggplot commands, there is a natural intuition for how to change this plot: for example swapping geom_bar with geom_line will make this a linechart. ggplot2 is an effective way to communicate your visualization structure to a machine and to another person.\nThe code below shows the elegance of dplyr, ggplot, and the pipe, to walk through a filter and aggregation of the starwars dataset, and then to compose a bar plot of average mass per species.\n\n\nrequire(dplyr)\nrequire(ggplot2)\n\nstarwars %>%\n  group_by(species) %>%\n  summarise(\n    n = n(),\n    mass = mean(mass, na.rm = TRUE)\n  ) %>%\n  ungroup() %>%\n  filter(n > 1, mass > 50) %>%\n  ggplot(aes(x = species, y = mass, size = n)) +\n  geom_bar(stat = 'identity') +\n  coord_flip() +\n  theme_bw(base_size = 16)\n\n\n\n\ndplyr & tidyr - a Grammar for Data Manipulation\n\n\n\ndplyr and tidyr have emerged as a grammar for data manipulation and data cleaning. They provide fundamental primitives in data manipulation with dplyr::group_by, dplyr::summarise, dplyr::filter, and dplyr::tally, but also provide primitives that handle much more complex cases, like tidyr::pivot_longer and tidyr::pivot_wider.\nThe grammar also has great ergonomics to minimize the amount of repetition when manipulating data. For example, many datasets name their variables with a specific convention. We may want to manipulate all variables from a specific group. In the example below, dplyr lets us aggregate all columns that have the suffix agg_me. We can even apply multiple aggregations easily.\n\n\nrequire(magrittr)\n\ndata = data.frame(group = sample(LETTERS, 100, replace = TRUE),\n                  y1_agg_me_not = 1:100,\n                  y2_agg_me = (1:100)^2,\n                  y3_agg_me = rnorm(100))\ndata %>% head() %>% kable\n\n\ngroup\ny1_agg_me_not\ny2_agg_me\ny3_agg_me\nO\n1\n1\n-1.0541310\nP\n2\n4\n-1.4184466\nA\n3\n9\n0.2145359\nH\n4\n16\n0.4361701\nT\n5\n25\n1.7084232\nY\n6\n36\n-0.1153280\n\n\n\nrequire(dplyr)\nrequire(tidyselect)\ndata %>%\n  filter(group != 'D') %>%\n  group_by(group) %>%\n  summarise(across(ends_with(\"agg_me\"), list(\"sum\" = sum, \"mean\" = mean))) %>%\n  ungroup() %>%\n  head() %>%\n  kable\n\n\ngroup\ny2_agg_me_sum\ny2_agg_me_mean\ny3_agg_me_sum\ny3_agg_me_mean\nA\n3978\n1989.0\n-0.2314485\n-0.1157243\nB\n12460\n3115.0\n0.6675846\n0.1668962\nC\n653\n326.5\n2.2269302\n1.1134651\nE\n22848\n4569.6\n3.2857382\n0.6571476\nF\n16196\n3239.2\n-0.3348661\n-0.0669732\nG\n10045\n5022.5\n0.0642200\n0.0321100\n\nWe can also pivot a “long” dataset into a “wide” one, especially for dynamic aggregation. Below, we have a common, “long” dataset listing impressions and clicks on various items for a user. Say we want to generate click through rates on each item, and then want to use those rates as features for a model.\n\n\ndata = data.frame(user = c(rep(\"J\", 3), rep(\"C\", 3), rep(\"N\", 3)),\n                  item = rep(c(\"Item1\", \"Item2\", \"Item3\"), 3),\n                  impressions = 1:9,\n                  clicks = 1:9)\ndata %>% head %>% kable\n\n\nuser\nitem\nimpressions\nclicks\nJ\nItem1\n1\n1\nJ\nItem2\n2\n2\nJ\nItem3\n3\n3\nC\nItem1\n4\n4\nC\nItem2\n5\n5\nC\nItem3\n6\n6\n\nUsing the long dataset it’s easy to create the per-user per-item click through rate.\n\n\ndata = data %>%\n  mutate(click_through_rate = clicks/impressions)\ndata %>% kable\n\n\nuser\nitem\nimpressions\nclicks\nclick_through_rate\nJ\nItem1\n1\n1\n1\nJ\nItem2\n2\n2\n1\nJ\nItem3\n3\n3\n1\nC\nItem1\n4\n4\n1\nC\nItem2\n5\n5\n1\nC\nItem3\n6\n6\n1\nN\nItem1\n7\n7\n1\nN\nItem2\n8\n8\n1\nN\nItem3\n9\n9\n1\n\nThen, we pivot the user-item level data into a user dataset, so that we have 3 user variables for the 3 click through rates.\n\n\nrequire(tidyr)\nrequire(tidyselect)\ndata %>%\n  pivot_wider(names_from = item, values_from = c(impressions, clicks, click_through_rate)) %>%\n  select(user, starts_with(\"click_through_rate\")) %>%\n  kable\n\n\nuser\nclick_through_rate_Item1\nclick_through_rate_Item2\nclick_through_rate_Item3\nJ\n1\n1\n1\nC\n1\n1\n1\nN\n1\n1\n1\n\ndplyr’s interface is consistent across many inputs, not just R dataframes. The input can be a spark dataframe, or even a parquet file, making it easy to transition from prototype code to production code. All of the above dplyr code can be executed agnostically, adding to the elegance and thoughtful thinking that goes into R grammars.\nRecipes - a Grammar for Data Preprocessing\n\n\n\nrecipes is the most recent grammar added to R, and is targeted towards improving data preprocessing, a universal challenge for all data scientists. The grammar lets you define several data preprocessing steps that can be composed into a recipe that transforms a data.frame. The recipe can then be applied to other datasets, giving complete reproducibility to data. For example, the recipe below trains an imputation step, which is then baked from a data.frame called data.\n\n\nrequire(recipes)\n\nn = 100\ndata = data.frame(\n  y = rnorm(n),\n  categorical = sample(LETTERS, n, replace = TRUE),\n  numerical = rnorm(n),\n  constant = 1\n)\n\nrec = recipe(y ~ categorical + numerical + constant, data = data) %>%\n  step_meanimpute(all_numeric()) %>%\n  step_modeimpute(all_nominal()) %>%\n  prep(data) %>%\n  bake(data)\n\n\n\nThis recipe can be reapplied to any dataframe, including an out of sample dataset, and will reapply the same imputation logic from data. For machine learning, you can preprocess a test set in the exact same way you preprocess the training set.\nHigh Performance Computing\n\n\n\nRcpp provides a boost to data science productivity by making functions faster. It offers rich integration between R and C++. Very similar to cython and pybind11 in Python, Rcpp can compile low level C and C++ code that can be orders of magnitude faster than interactive languages like R. For example, for loops can be made significantly faster by compiling them in C++. OpenMP and Intel TBB can make C++ algorithms multithreaded, instead of having to rely on Unix like forks. Memory allocation can be controlled better, reducing the memory footprint of an algorithm while simultaneously making it faster.\nJust like the beautiful ergonomics in dplyr, Rcpp takes care of many barriers of entry into high performance computing. The package will compile C++ source code, load the C symbol table into R, and convert between R types and C++ types for you. Using Rcpp::sourceCpp or devtools::load_all, you can have an editor open, write C++ code, and immediately bring optimized functions into R without restarting the session or managing a Makefile. This combines the performance of C++ with the interactivity of R.\nBecause of Rcpp’s ease of use, there are over 1000 R packages using Rcpp. This aspect of computing is one of the biggest reasons why R has changed so much in recent years.\nMultilingual Data Science\n\n\n\nRStudio has been pivoting itself from not only developing R software, but also developing data science tools in general. For example, see its page on the Essentials of Data Science and Advanced Data Science.\nReticulate is the most noteworthy package. It allows an R user to invoke Python functions while still inside an R session. The package takes care of converting Python and R data types for you: it is possible to invoke a python function that uses an R dataframe as input, and under the hood the dataframe will be converted to a pandas type. Data scientists that are multilingual in Python and R do not need to have two notebooks running in parallel. At the same time, broader data science collaboration is enabled.\nReticulate’s integration is broad. It is embedded in RStudio and RMarkdown, where you can develop Python scripts just as easily as R scripts. You can even create RStudio Notebooks that weave native Python code cells and R code cells together, where RStudio will transfer data types between languages for you.\nThrough Python and C++ bindings, R is able to elegantly integrate with Tensorflow and Keras, which were primarily developed in Python and C++. This allows RStudio to act as a primary hub for multiple data science languages.\nPackage Development\n\n\n\nDeveloping a package in R that can be distributed to others is an easy and uniquely interactive experience. The package devtools provides all the tools a developer will need, and you will not need to exit the R session to go to bash or any other environment. This minimizes distractions and creates a productive developer workflow. Having a good package development experience is crucial for growing a productive community of open source developers.\nTo create a package, a user collects a series of .R files into an /R/ directory as if they were going to be sourced. To import the package into the R session, just run devtools::load_all(). During the development process, modify the source files directly in RStudio, and reload the package again using devtools::load_all(). You will not need to restart the R session. To create manual pages according to docstrings, simply run devtools::document(). To test the package, simply run devtools::test(). To release a package to the open source simply run devtools::release(). All of this is done without toggling environments; the developer can stay inside RStudio.\nRunning tests interactively is a major productivity boost to debugging software. Tests are written in a self contained script, so you can run lines one by one to prepare data and run your functions. R is meant to be interactive, so when a test fails you can use the current R session to rerun a test and use debugger tools to figure out what is wrong. You will not need separate test infrastructure, so debugging a unit test truly feels like combing your code line by line. Being able to stay inside one single R session without restarts or other third party infrastructure streamlines rapid iteration of editing source code, running unit tests, running a debugger, and releasing code.\nThe R community has thousands of packages and open source developers. To maintain a healthy ecosystem where packages are compatible with each other, developers can make use of devtools::revdep(). This function will lookup all packages that depend on package X, and run their unit tests against the development version of package X, allowing developers to make safe releases into the community.\nRStudio\n\n\n\nRStudio is an IDE, notebook, debugger, and profiler all in one. You do not need separate UIs or terminals to iterate and produce high quality code. This creates great developer flow.\nFor better productivity, you can run R on remote servers that are always on and always available. Combined with AWS’s customizeable hardware, this lets you do data science from anywhere with any amount of resources. RStudio Server lets you connect to RStudio on a remote machine using your browser. If you don’t want to maintain the hardware, you can also use RStudio Cloud. This is one of the most advanced browser based data science IDEs that exists.\nPackage Documentation\n\n\n\nDocumenting software is a crucial part of developing successful open source software. In order to produce high quality software, the experience of writing documentation needs to be frictionless. R makes developing packages with high quality documentation easy. To document a function, simply add a docstring next to the function’s source code. To create documentation on larger topics, you can use RMarkdown to create a notebook vignette that contains any combination of text, HTML, LaTeX and R/Python/C++ code cells. These notebooks can become part of the package documentation. As seen many times before, R takes common workflows - for example creating a Notebook to demo code - and turns them into paths for writing documentation.\nUsing pkgdown and pkgdown::build_site() you can build beautiful html websites containing documentation and vignettes from your package. The function builds the entire website, html files, and other assets that can be simply uploaded to github and turned into a website using github pages.\nUsing distill you can create an entire data science blog, such as this one!\n\n\n\n",
    "preview": "https://github.com/tidyverse/ggplot2/raw/master/man/figures/logo.png",
    "last_modified": "2021-04-11T10:46:01-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-09-the-mathematics-of-the-elastic-net/",
    "title": "The Mathematics of the Elastic Net",
    "description": "OLS with L1 and L2 penalties.",
    "author": [
      {
        "name": "Jeffrey C. Wong",
        "url": {}
      }
    ],
    "date": "2021-04-07",
    "categories": [],
    "contents": "\nAuthor’s note: This post is largely a rehash of many of the original elastic net and glmnet papers. I hope that having another voice describe the elegance of the elastic net will help others understand it. I have linked to all of the original documents to the best I can.\nThe elastic net adds L1 and L2 penalties to OLS, and is used to shrink coefficients towards zero. This can help with overfitting, as well as building an interpretive model from many features. When there is structure in coefficient-specific penalties, regularization can mimic a hierarchical model.\nWe start with a feature matrix, \\(X \\in \\mathbb{R}^{n \\times p}\\), a response vector, \\(y \\in \\mathbb{R}^n\\), and a given \\(\\alpha\\). The elastic net formulates the problem\n\\[\\beta^{(\\lambda)} = \\arg\\min \\sum_{i=1}^n (y_i -\\beta_0 -x_i^T \\beta)^2 + \\lambda \\sum_{j=1}^p (0.5(1-\\alpha)\\beta_j^2 + \\alpha |\\beta_j|).\\]\nThe first term is the usual OLS term and the second term is a combination of L1 and L2 regularization.\nPhysical Interpretation of the Regularization\nThe 2 norm on \\(\\beta\\) incentivizes the program to return coefficients that are small in magnitude. Likewise, the 1 norm incentivizes coefficients that are exactly zero. This prevents the exaggeration of effects in a model, while simultaneously serving as a form of model selection and interpretation.\nRegularization is also similar to a prior. L2 regularization is similar to OLS with a gaussian prior on the parameters, that has a prior mean of 0 and a prior variance of \\(1/\\lambda\\). L1 regularization is similar to a laplacian prior. The relationship is explained here with a compact stack overflow description here.\nSolving the Program\nWhen \\(X\\) is centered and scaled to have zero mean and unit variance, the optimization problem can be solved using coordinate descent, with the update step:\n\\[\\beta^{(\\lambda)}_j = \\frac{S(\\frac{1}{n} \\sum_{i=1}^n (x_{i,j}\\varepsilon_i + \\beta^{(\\lambda)}_j), \\lambda \\alpha)}{1 + \\lambda(1 - \\alpha)}\\]\nwhere \\(S(x, \\lambda) = \\text{sign}(x) \\cdot (|x| - \\lambda)_+\\) is the soft thresholding function.\nThis produces an algorithm with the form\n# Given X, y, lambda, alpha.\nfor cycle in 1:max_cycles\n  for j in 1:p\n    for it in 1:max_iters\n      beta_j = <do update step above>\nSearching \\(\\lambda\\)\nThe amount of regularization to use is always a question when fitting the elastic net. More regularization will more aggressively shrink the coefficients to zero. From the physical interpretation section above, regularization is like a prior, and careful thought also goes into choosing the prior. Usually, we cross validate and search for an optimal \\(\\lambda\\) that minimizes an out-of-sample metric. Fortunately there is a smart strategy for how to pick a starting set of \\(\\lambda\\) to explore (talk, stack overflow).\nSay a good set of \\(\\lambda\\) ranges from \\(\\lambda_{max}\\) to \\(\\lambda_{min}\\), and is logarithmically spaced apart, where \\(\\lambda_{max}\\) is the smallest \\(\\lambda\\) such that the coefficient vector is the zero vector and \\(\\lambda_{min}\\) is some multiple of \\(\\lambda_{max}\\).\nWhen \\(X\\) is centered and scaled to have zero mean and unit variance, and \\(y\\) is centered to have zero mean, then\n\\[\\lambda_{max} = \\frac{\\max(|X^T y|)}{n \\alpha}.\\]\nIn glmnet::glmnet, \\(\\lambda_{min} = .0001 \\lambda_{max}\\) if \\(n > p\\). It should be noted that when \\(\\alpha = 0\\), \\(\\lambda_{max}\\) does not exist, so glmnet intercepts \\(\\alpha\\) and pretends it is 0.001.\nAdding this layer to search for \\(\\lambda\\) means the optimization algorithm above gains a fourth nested for loop.\n# Given X, y, alpha.\nfor cycle in 1:max_cycles\n  for j in 1:p\n    for l in lambda: \n      for it in 1:max_iters\n        beta_j = <do update step above>\nThis sounds like it is untractable, but there are several optimizations that can make the algorithm fast.\nComputational performance\nThe above two sections are sufficient enough to build a lightweight elastic net solver. This section describes specific optimizations that make the algorithm faster, but ultimately are not relevant for how to use the elastic net as an end user.\nUpdates via Covariance\nNote that the \\(\\sum_i x_{i,j}\\varepsilon_i\\) term can be decomposed into \\(\\sum_i x_{i,j}(y_{i} - x_{i}^T \\beta)\\). This can be computed very efficiently from a few vectorized operations that are computed just once outside of all of the loops. We first compute and store \\(X^T X\\) and \\(X^T y\\). When \\(X\\) is sparse the linear algebra can be optimized. Then \\(\\sum_i x_{i,j}\\varepsilon_i = (X^T y)[j] - (X^T X)[,j]^T\\beta\\), i.e. the j-th component of \\(X^T y\\) and the dot product between the j-th column of \\(X^T X\\) and \\(\\beta\\).\nReuse \\(X^T y\\) from searching \\(\\lambda\\)\nWhen a smart set of \\(\\lambda\\) is initialized, we can store the product \\(X^T y\\), which is then used as part of the covariance update strategy.\nPathwise Coordinate Descent\nThe elastic net algorithm can compute the coefficient vector for several values of \\(\\lambda\\). Suppose we have a monotonically decreasing sequence for \\(\\lambda\\), \\({\\lambda} = {\\lambda_{max}, \\lambda_2, \\ldots}\\). By definition, the coefficient vector for \\(\\lambda_{max}\\) is the zero vector. The next \\(\\lambda\\) in the sequence will have the update step \\(\\beta^{(\\lambda)}_j = 0\\) as long as \\(|X^Ty[j]| < \\lambda \\alpha n\\). This check is a simple lookup since \\(X^T y\\) is cached, and can bypass several update steps.\nActive Sets\nAfter doing one pass on the outermost loop that iterates on cycles, we check which coefficients are nonzero. In the second cycle, instead of iterating on the \\(p\\) coefficients, we iterate only on the nonzero ones. These are the active sets. Finally, at the end we do one last cycle iterating on all coefficients. If the nonzeros have not changed, we conclude the algorithm.\nCentering and Scaling\nMuch of the elastic net algorithm assumes \\(X\\) and \\(y\\) have been centered and scaled. Say we start with a feature matrix \\(\\tilde{X}\\) which is not centered or scaled. Centering \\(\\tilde{X}\\) makes it become dense, and many sparse linear algebra optimizations are lost.\nInstead, we leverage the formula that centering and scaling can be written as\n\\[X = (\\tilde{X} - 1\\mu_\\tilde{x}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}.\\]\nwith \\(\\mu_\\tilde{x}\\) and \\(\\sigma_\\tilde{x}\\) column vectors containing the column means and column standard deviations of \\(\\tilde{X}\\), and likewise for \\(\\tilde{y}\\).\nThe key computations can be written as:\n\\[\\begin{align}\nX^T y &= [(\\tilde{X} - 1\\mu_\\tilde{x}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}]^T (\\tilde{y} - 1\\mu_\\tilde{y}).\\\\\nX^T X &= [(\\tilde{X} - 1\\mu_\\tilde{x}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}]^T [(\\tilde{X} - 1\\mu_\\tilde{x}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}] \\\\\n&= \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\tilde{X}^T \\tilde{X} \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} - n (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}}) (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}})^T.\n\\end{align}\\]\nElastic Net with Weights\nThis section discusses the extension of elastic net to use weights, similar to weighted least squares.\nCoordinate Descent with Weights\nAssume that \\(X\\) and \\(y\\) have been centered and scaled without weights, so that their unweighted means are 0 and unweighted variances are 1. The update step for weighted elastic net is\n\\[\\beta_j^{(\\lambda)} = \\frac{S(\\sum_{i=1}^n (w_i x_{i,j}(\\varepsilon_i + x_{i,j}\\beta_j^{(\\lambda)})), \\lambda \\alpha)}{\\sum_i w_i x_{i,j}^2 + \\lambda(1 - \\alpha)}\\]\nThough it looks more complex than before, using \\(w_i = 1/n\\) will reduce the update step to the original unweighted update step.\nNow suppose that \\(X\\) and \\(y\\) were centered and scaled with weights, so that their weighted means are 0 and weighted variances are 1. By taking advantage of the definition \\(\\sum_i w_i x_{i,j}^2 = \\sum_i w_i\\) we can recover the more familiar formula\n\\[\\beta_j^{(\\lambda)} = \\frac{S(\\sum_{i=1}^n (w_i x_{i,j}\\varepsilon_i + \\beta_j^{(\\lambda)}), \\lambda \\alpha)}{\\sum_i w_i + \\lambda(1 - \\alpha)}.\\]\nLike before, this update step can use vectorized operations. The key computations can be written as:\n\\[\\begin{align}\nX^T W y &= [(\\tilde{X} - 1\\mu_{\\tilde{X}}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}]^T \\text{Diagonal}(w) ({\\tilde{y}}) \\\\\n  &= \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\tilde{X}^T \\text{Diagonal}(w) ({\\tilde{y}}) - \n     \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\mu_{\\tilde{X}} w^T \\tilde{y}. \\\\\nX^T W X &= [(\\tilde{X} - 1\\mu_{\\tilde{X}}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}]^T [({\\tilde{X}} - 1\\mu_{\\tilde{X}}^T) \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix}] \\\\\n&= \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\tilde{X}^T \\text{Diagonal}(w) \\tilde{X} \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} -\n  \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\tilde{X}^T w (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}})^T -\n  (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}}) w^T \\tilde{X}\\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} +\n  (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}}) (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}})^T \\sum_i w_i \\\\\n&= \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} \\tilde{X}^T \\text{Diagonal}(w) \\tilde{X} \\begin{bmatrix} 1/\\sigma_{\\tilde{x}, 1} & & \\\\ & \\ddots & \\\\ & & 1/\\sigma_{\\tilde{x}, p} \\end{bmatrix} -\n  (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}}) (\\frac{\\mu_\\tilde{x}}{\\sigma_\\tilde{x}})^T \\sum_i w_i. \\\\\n\\lambda_{max} &= \\max \\frac{|X^T W y|}{\\alpha}.\n\\end{align}\\]\nVectorizing for Multiple Outcome Variables\nMany applications will track multiple outcome variables, so that \\(Y \\in \\mathbb{R}^{n \\times o}\\) is a matrix of \\(o\\) outcomes per observation. When the outcomes are independent, there is a fast way to fit multiple OLS regressions to the same feature matrix. Likewise, there is a fast way to do this for multiple elastic nets.\nThe bulk of the computation for a single \\(y\\) is in the covariance update step\n\\[\\sum_i x_{i,j}\\varepsilon_i = (X^T y)[j] - (X^T X)[,j]^T\\beta.\\]\n\\(y\\) and \\(\\beta\\) are column vectors. It is possible to update the j-th coefficient for all outcomes simultaneously. We vectorize over \\(o\\) outcomes to produce and cache the intermediate matrix \\(X^T Y \\in \\mathbb{R}^{p \\times o}\\), and reuse \\(X^T X\\) across outcomes.\nHowever, different outcome variables can reach convergence differently. When updating the j-th coefficient, we would like to subset the columns of \\(X^T Y\\) to those outcomes which have not converged yet. This subsetting creates a deep copy of the matrix, and can be counter productive to the vectorization over multiple outcomes.\nIn practice, it may be easier to implement a job coordinator that computes \\(X^T Y\\) and \\(X^T X\\) apriori. These intermediates are stored in shared memory. Then, the coordinator assigns the task of estimating \\(\\beta\\) for a single outcome to a worker, which reads the intermediates from shared memory.\nExtensions\nDifferential Shrinkage\nThe standard description of the elastic net assumes a constant penalty across all coefficients, as seen in\n\\[\\beta^{(\\lambda)} = \\arg\\min \\sum_{i=1}^n (y_i -\\beta_0 -x_i^T \\beta)^2 + \\lambda \\sum_{j=1}^p (0.5(1-\\alpha)\\beta_j^2 + \\alpha |\\beta_j|).\\]\nSometimes we want to augment the penalty for different coefficients. The library glmnet introduces the parameter penalty.factor, which multiplies the \\(\\lambda\\) term by a \\(\\gamma_j \\geq 0\\) that varies for different coefficients. The algorithm for solving elastic net is flexible for differential shrinkage, where the loop over coefficients scales the \\(\\lambda\\) penalty term by \\(\\gamma_j\\). In addition, the initialization of the \\(\\lambda\\) path should use\n\\[\\lambda_{max} = \\max \\text{Diagonal}(1/\\gamma) \\frac{|X^T W y|}{n \\alpha}.\\]\nReferences\nhttps://web.stanford.edu/~hastie/TALKS/glmnet.pdf\nhttps://web.stanford.edu/~hastie/Papers/glmnet.pdf\nhttps://stats.stackexchange.com/questions/166630/glmnet-compute-maximal-lambda-value\nhttps://stats.stackexchange.com/questions/13617/how-is-the-intercept-computed-in-glmnet\nhttps://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-09T14:26:09-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-27-equivalence-between-tikhonov-regularization-and-gaussian-priors/",
    "title": "The Special Equivalence between Tikhonov Regularization and Gaussian Priors",
    "description": "Straddling Bayesian and Frequentist Statistics.",
    "author": [
      {
        "name": "Jeffrey C. Wong",
        "url": {}
      }
    ],
    "date": "2020-12-27",
    "categories": [],
    "contents": "\nIn this post we will show that the maximum a-posteriori (MAP) estimator of a normal-normal is equal to the estimator from Tikhonov regularization.\nIntroduction\nThroughout this post we will build on ordinary least squares. First, we will assume that there is a random variable, \\(y\\), that is normally distributed and its mean is a linear combination of features, \\(x\\), so that \\(Y \\sim N(x^T\\beta, \\Sigma)\\).\nOptionally, the parameter vector \\(\\beta\\) can have a prior on it, in the form \\(\\beta \\sim N(\\mu_0, \\Sigma_0)\\).\nMaximum Likelihood for Normally Distributed Data\nIn frequentist statistics, we will write the likelihood of the data, then find an estimate of the parameters that will maximize the likelihood. The likelihood as a function of \\(\\beta\\) is\n\\[ L(\\beta) = \\prod_i N(y_i | x_i, \\beta, \\Sigma) = \\prod_i \\frac{1}{\\sqrt{(2 \\pi)^k |\\Sigma|}} \nexp({-\\frac{1}{2} (y_i - x_i^T \\beta)^T \\Sigma^{-1} (y_i - x_i^T \\beta)}).\\] The MLE estimate for \\(\\beta\\) will maximize the log-likelihood with respect to \\(\\beta\\), by differentiating it and finding its root. This produces the MLE estimate\n\\[\\hat{\\beta}^{MLE} = (X^T X)^{-1} X^T y.\\]\nMaximum a Posteriori\nWhen there is a gaussian prior in the form \\(\\beta \\sim N(\\mu_0, \\Sigma_0)\\), we use Baye’s rule to multiply the likelihood with the prior to get the posterior probability of \\(\\beta\\). Since we are multiplying two normals, we can add their exponents. The posterior takes the form of another normal distribution.\n\\[\\begin{align}\np(\\beta|y, x, \\Sigma) &= \\prod_i N(y_i | x_i, \\beta, \\Sigma) \\cdot N(\\beta | \\mu_0, \\Sigma_0) \\\\\n  &\\propto\n  \\prod_i \\frac{1}{|\\Sigma|} \n  exp({-\\frac{1}{2} \\big((y_i - x_i^T \\beta)^T \\Sigma^{-1} (y_i - x_i^T \\beta) - (\\beta - \\mu_0)^T \\Sigma_0^{-1} (\\beta - \\mu_0)\\big)}).\n\\end{align}\\]\nThe posterior turns out to be another normal distribution, \\(N(\\mu_1, \\Sigma_1)\\) (wiki), where\n\\[\\begin{align}\n\\Sigma_1 &= (\\Sigma_0^{-1} + n \\Sigma^{-1})^{-1} \\\\\n\\mu_1 &= \\Sigma_1 (\\Sigma_0^{-1} \\mu_0 + \\Sigma^{-1} \\sum_i{y_i})\n\\end{align}\\]\nThe maximum a-posteriori estimator (wiki) estimates the parameter vector as the mode of the posterior distribution. This is done by differentiating the posterior and solvings its root, similar to MLE. Taking the log posterior probability and then maximizing it gives\n\\[\\hat{\\beta}^{MAP} = \\arg max_{\\beta} \n- (y-X\\beta)^T \\Sigma^{-1} (y-X\\beta)\n- (\\beta-\\beta_0)^T \\Sigma_0^{-1} (\\beta-\\beta_0).\\] Recall that \\(\\Sigma\\) is fixed, and \\(\\mu_0\\) and \\(\\Sigma_0\\) are inputs for the prior. Differentiating and solving, we can show the MAP estimator is equal to Tikhonov regularization.\n\\[\\hat{\\beta}^{MAP} = (X^T X + \\Sigma_0)^{-1} (X^T y + \\Sigma_0 \\mu_0).\\]\nEquivalence between MLE and MAP\nWhen the prior is a constant everywhere, it factors out of the posterior probability as a constant. That means the MLE estimator is a special case of MAP when the prior is a uniform distribution.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-07T13:25:22-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-25-choose-distill-for-writing-a-tech-blog/",
    "title": "Choose RMarkdown + Distill for writing a Tech Blog",
    "description": "RMarkdown and Distill are powerful tools for scientific communication.",
    "author": [
      {
        "name": "Jeffrey C. Wong",
        "url": {}
      }
    ],
    "date": "2020-12-25",
    "categories": [],
    "contents": "\nRMarkdown is a Champion for Scientific Communication\nRMarkdown has had a long history in scientific communication. Using RMarkdown, you can create beautifully rendered technical documents that can be hosted online or sent as pdfs. The documents weave together the output from code, latex, as well as other web tools like html, css, and javascript. By putting data analysis code right next to text, the author can describe and discuss individual steps in analysis, and show how to reproduce it using software. RMarkdown allows authors to construct an entire scientific narrative with the spirit of the scientific method. It facilitates this approach to scientific communication by creating great development flow between code and discussion: the code you write for development is the same code that you share to others to let them read and follow along.\nHere are examples of how RMarkdown embeds essential parts of scientific communication into one environment. First, we can write latex.\n\\[ \\int_0^1 x dx = \\frac{1}{2}.\\]\nNext, we can illustrate source code for functions\n\n\nfoo = function(x, y) {\n  (x-y)^2 %>% sum() %>% sqrt()\n}\n\n\n\nFinally, we can execute code inline, and can also generate visualizations.\n\n\na = 5\nb = a^2\nprint(b)\n\n\n[1] 25\n\n\n\n\nDistill is a Better Publishing Platform for Research\nDistill is both a publishing framework and machine learning research journal. It is advancing scientific communication by breaking the barriers of traditional pdf documents. Distill articles are html pages that allow publishing new kinds of scientific narratives, including those that have interactive visualizations, videos, and demos. It also follows scientific writing, listing the authors, date published, references, footnotes, and an appendix.\nDevelopers at RStudio have integrated Distill articles into RMarkdown with the #rstats Distill package. RMarkdown users can create Distill articles that can be submitted to the research journal. In addition, they’ve made it easy to collate Distill html articles into an online blog. This further enhances scientific communication because your development environment can also be used for online publishing and content management, creating a single end-to-end environment for development, sharing, and publishing. The Distill package creates the listing page that indexes all blog posts, adds a search bar to the blog, and adds comments and share links to each blog post. You can also link to the underlying RMarkdown source code to show how the blog post was generated. In this way, the blog post turns into a technical document that embodies RMarkdown’s reproducible research features.\nA Simple End-to-End Tech Stack\nA full Distill blog can be hosted using as few as two components, that are completely free. Publishing can be done without maintaining a server or a database.\nRMarkdown, and Distill to build the blog. When the blog is built, a series of .html files are generated that can be uploaded to a webhost.\ngithub pages can host the blog online for free.\n\n\n\n",
    "preview": "posts/2020-12-25-choose-distill-for-writing-a-tech-blog/choose-distill-for-writing-a-tech-blog_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2021-04-07T13:25:22-07:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
